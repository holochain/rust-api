initSidebarItems({"enum":[["Constants","Raw 0MQ socket option constants."],["DecodeError","Errors that can occur while decoding Z85."],["EncodeError","Errors that can occur while encoding Z85."],["Error","An error returned by a 0MQ API function."],["Mechanism","Security Mechanism"],["SocketType","Socket types"]],"fn":[["has","Return true if the used 0MQ library has the given capability."],["poll","Poll for events on multiple sockets."],["proxy","Start a 0MQ proxy in the current thread."],["proxy_with_capture","Start a 0MQ proxy in the current thread, with a capture socket."],["version","Return the current zeromq version, as `(major, minor, patch)`."],["z85_decode","Decode a binary key from Z85-encoded text."],["z85_encode","Encode a binary key as Z85 printable text."]],"static":[["DONTWAIT","Flag for socket `send` methods that specifies non-blocking mode."],["POLLERR","For `poll()`, specifies to signal when an error condition is present on a socket.  This only applies to non-0MQ sockets."],["POLLIN","For `poll()`, specifies to signal when a message/some data can be read from a socket."],["POLLOUT","For `poll()`, specifies to signal when a message/some data can be written to a socket."],["SNDMORE","Flag for socket `send` methods that specifies that more frames of a multipart message will follow."]],"struct":[["Context","Handle for a 0MQ context, used to create sockets."],["CurveKeyPair","A CURVE key pair generated by 0MQ."],["Message","Holds a 0MQ message."],["PollItem","Represents a handle that can be `poll()`ed."],["Socket","A socket, the central object in 0MQ."]],"type":[["PollEvents","Type representing pending socket events."],["Result","`zmq`-specific Result type."]]});